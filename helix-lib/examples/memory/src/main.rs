mod queries; // Generated by build.rs

use helix_lib::{HelixDB, ResponseExt}; // Import ResponseExt for .json() and .get_field()
use serde::Deserialize;
use sonic_rs::json;

// Define response types for our queries
#[derive(Deserialize, Debug)]
struct GetUsersResponse {
    users: Vec<UserData>,
}

#[derive(Deserialize, Debug)]
struct UserData {
    id: String,
    label: String,
    name: Option<String>,
    email: Option<String>,
    created_at: Option<String>,
    updated_at: Option<String>,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("Test Consumer: Simplified execute() API Demo\n");

    // Get pre-compiled configuration from generated queries module
    let config = queries::config().expect("Config should be generated from schema.hx");

    println!("âœ“ Config loaded from generated queries.rs");
    println!("  Schema embedded: {}", config.schema.is_some());

    // Create database with pre-compiled schema
    let db_path = "/tmp/test_consumer_db";

    // Clean up
    if std::path::Path::new(db_path).exists() {
        std::fs::remove_dir_all(db_path)?;
    }

    let db = HelixDB::new(db_path, config)?;

    println!("âœ“ Database initialized successfully");
    println!("  Path: {}", db.path().display());

    //----------------------------------------------------------------
    // Demo 1: Execute + deserialize pattern
    //----------------------------------------------------------------
    println!("\n--- Demo 1: execute().deserialize() pattern ---");
    let response = db.execute("GetUsers", json!({}))?;
    let data: GetUsersResponse = response.deserialize()?;
    println!("âœ“ Got {} users", data.users.len());

    //----------------------------------------------------------------
    // Demo 2: Chained execution
    //----------------------------------------------------------------
    println!("\n--- Demo 2: Chained pattern ---");
    let data: GetUsersResponse = db.execute("GetUsers", json!({}))?.deserialize()?;
    println!("âœ“ Got {} users (chained)", data.users.len());

    //----------------------------------------------------------------
    // Demo 3: Using .json() for dynamic access
    //----------------------------------------------------------------
    println!("\n--- Demo 3: Dynamic JSON with .json() ---");
    let json_value = db.execute("GetUsers", json!({}))?.json()?;
    println!("âœ“ JSON value: {}", json_value);

    //----------------------------------------------------------------
    // Demo 4: Using .get_field() for field extraction
    //----------------------------------------------------------------
    println!("\n--- Demo 4: Field extraction with .get_field() ---");
    let users: Vec<UserData> = db.execute("GetUsers", json!({}))?.get_field("users")?;
    println!("âœ“ Extracted 'users' field: {} items", users.len());

    println!("\nðŸŽ‰ Simplified execute() API works!");
    println!("   Single method: execute(query, params) -> Response");
    println!("   Chain with .deserialize(), .json(), or .get_field()");

    Ok(())
}
