//! HelixDB Embeddable SDK
//!
//! A lightweight, embeddable graph database with vector search capabilities.
//!
//! # Features
//! - Build-time schema compilation
//! - Handler-based query execution
//! - Type-safe response deserialization
//! - Compatible with HelixDB server databases
//!
//! # Example
//! ```no_run
//! use helix_lib::{HelixDB, ResponseExt};
//! use serde::Deserialize;
//! use sonic_rs::json;
//!
//! mod queries; // Generated by build.rs
//!
//! #[derive(Deserialize)]
//! struct GetUsersResponse {
//!     users: Vec<User>,
//! }
//!
//! # fn main() -> Result<(), Box<dyn std::error::Error>> {
//! let config = queries::config()?;
//! let db = HelixDB::new("./my_data", config)?;
//!
//! // Execute query and deserialize
//! let response = db.execute("GetUsers", json!({}))?;
//! let data: GetUsersResponse = response.deserialize()?;
//!
//! // Or chain it
//! let data: GetUsersResponse = db.execute("GetUsers", json!({}))?.deserialize()?;
//! # Ok(())
//! # }
//! ```

pub mod errors;
pub use errors::{HelixError, Result};

pub mod build;

// Re-export everything needed by generated queries.rs
// This allows users to only depend on helix-lib

// Re-export helix-db modules
pub use helix_db::{
    embed,
    embed_async,
    field_addition_from_old_field,
    field_addition_from_value,
    field_type_cast,
    helix_engine::{
        reranker,
        traversal_core::{
            config::{Config, GraphConfig, VectorConfig},
            ops,
            traversal_value::TraversalValue,
        },
        types::GraphError,
        vector_core::vector::HVector,
    },
    helix_gateway::{
        embedding_providers::{EmbeddingModel, get_embedding_model},
        mcp::mcp::{MCPHandler, MCPHandlerSubmission, MCPToolInput},
        router::router::{BasicHandlerFn, Handler, HandlerFn, HandlerInput, HandlerSubmission},
    },
    // Re-export macros
    node_matches,
    props,
    protocol::{
        format::Format,
        request::{Request, RequestType},
        response::Response,
        value::{
            Value,
            casting::{CastType, cast},
        },
    },
    utils::{
        id::{ID, uuid_str},
        items::{Edge, Node},
        properties::ImmutablePropertiesMap,
    },
};

// Re-export helix-macros
pub use helix_macros::{handler, mcp_handler, migration, tool_call};

// Re-export third-party dependencies
pub use bumpalo::Bump;
pub use chrono::{DateTime, Utc};
pub use heed3::RoTxn;
pub use sonic_rs::{Deserialize, Serialize, json};

// Re-export std types commonly used
pub mod collections {
    pub use std::collections::{HashMap, HashSet};
}
pub mod sync {
    pub use std::sync::Arc;
}
pub mod time {
    pub use std::time::Instant;
}

// Internal imports for HelixDB implementation
use helix_db::helix_engine::storage_core::{HelixGraphStorage, version_info::VersionInfo};
use std::path::{Path, PathBuf};
use std::sync::Arc;

/// The main embeddable HelixDB instance.
///
/// This struct provides a lightweight, embeddable graph database with vector search capabilities.
/// Database directories created with HelixDB are compatible with the HelixDB server,
/// allowing seamless transitions between embedded and server deployments.
///
/// # Example
/// ```no_run
/// mod queries; // Generated by build.rs
/// use helix_lib::HelixDB;
///
/// let config = queries::config().unwrap_or_default();
/// let db = HelixDB::new("./my_data", config)?;
/// ```
pub struct HelixDB {
    path: PathBuf,
    storage: Arc<HelixGraphStorage>,
}

impl HelixDB {
    /// Creates a new HelixDB database with pre-compiled schema.
    ///
    /// # Arguments
    /// * `path` - Directory path where the database files will be created
    /// * `config` - Pre-compiled configuration from `queries::config()`
    ///
    /// # Returns
    /// A new `HelixDB` instance ready for use.
    ///
    /// # Example
    /// ```no_run
    /// mod queries; // Generated by build.rs
    /// use helix_lib::HelixDB;
    ///
    /// let config = queries::config().expect("Config should be generated");
    /// let db = HelixDB::new("./my_graph_db", config)?;
    /// ```
    pub fn new<P: AsRef<Path>>(path: P, config: Config) -> Result<Self> {
        let path = path.as_ref();

        // Initialize storage with pre-compiled config from queries::config()
        let version_info = VersionInfo::default();
        let storage = Arc::new(
            HelixGraphStorage::new(
                path.to_str()
                    .ok_or_else(|| HelixError::InvalidPath(path.display().to_string()))?,
                config,
                version_info,
            )
            .map_err(|e| {
                HelixError::StorageError(format!("Failed to initialize storage: {}", e))
            })?,
        );

        Ok(Self {
            path: path.to_path_buf(),
            storage,
        })
    }

    /// Execute a query by name using handlers registered via #[handler] macro.
    ///
    /// Returns a raw Response that can be deserialized using ResponseExt methods.
    ///
    /// # Arguments
    /// * `query_name` - Name of the query (e.g., "GetUsers", "CreateUser")
    /// * `params` - Parameters for the query (will be serialized to JSON)
    ///
    /// # Returns
    /// The raw query Response.
    ///
    /// # Example
    /// ```no_run
    /// use helix_lib::{HelixDB, ResponseExt};
    /// use sonic_rs::json;
    /// use serde::Deserialize;
    ///
    /// #[derive(Deserialize)]
    /// struct GetUsersResponse {
    ///     users: Vec<User>,
    /// }
    ///
    /// # fn example(db: &HelixDB) -> Result<(), Box<dyn std::error::Error>> {
    /// // Execute and deserialize
    /// let response = db.execute("GetUsers", json!({}))?;
    /// let data: GetUsersResponse = response.deserialize()?;
    ///
    /// // Or chain it
    /// let data: GetUsersResponse = db.execute("GetUsers", json!({}))?.deserialize()?;
    ///
    /// // Or use json() for dynamic access
    /// let json_value = db.execute("GetUsers", json!({}))?.json()?;
    ///
    /// // Or extract a specific field
    /// let users: Vec<User> = db.execute("GetUsers", json!({}))?.get_field("users")?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn execute<T: Serialize>(&self, query_name: &str, params: T) -> Result<Response> {
        use std::collections::HashMap;

        // Collect all registered handlers from the user's binary
        let handlers: HashMap<String, BasicHandlerFn> = inventory::iter::<HandlerSubmission>()
            .map(|submission| {
                let handler = &submission.0;
                (handler.name.to_string(), handler.func)
            })
            .collect();

        // Find the requested handler
        let handler = handlers.get(query_name).ok_or_else(|| {
            HelixError::StorageError(format!(
                "Query '{}' not found. Available queries: {:?}",
                query_name,
                handlers.keys().collect::<Vec<_>>()
            ))
        })?;

        // Serialize parameters to JSON
        let body = sonic_rs::to_vec(&params).map_err(|e| {
            HelixError::StorageError(format!("Failed to serialize parameters: {}", e))
        })?;

        // Create Request struct
        let body_bytes = bytes::Bytes::from(body);
        let request = Request {
            name: query_name.to_string(),
            req_type: RequestType::Query,
            api_key: None,
            body: body_bytes,
            in_fmt: Format::Json,
            out_fmt: Format::Json,
        };

        // Create HelixGraphEngine wrapper
        let graph = Arc::new(helix_db::helix_engine::traversal_core::HelixGraphEngine {
            storage: self.storage.clone(),
            mcp_backend: None,
            mcp_connections: None,
        });

        // Create HandlerInput
        let input = HandlerInput { graph, request };

        // Execute handler
        handler(input)
            .map_err(|e| HelixError::StorageError(format!("Query execution failed: {}", e)))
    }

    /// Returns the database path.
    pub fn path(&self) -> &Path {
        &self.path
    }

    /// Returns a reference to the underlying storage engine.
    pub fn storage(&self) -> &Arc<HelixGraphStorage> {
        &self.storage
    }
}

/// Extension trait for Response to provide deserialization helpers
pub trait ResponseExt {
    /// Deserialize the response body to a specific type
    fn deserialize<T>(&self) -> Result<T>
    where
        T: for<'de> Deserialize<'de>;

    /// Get the response as a dynamic JSON Value
    fn json(&self) -> Result<sonic_rs::Value>;

    /// Extract a specific field from the response
    fn get_field<T>(&self, field: &str) -> Result<T>
    where
        T: for<'de> Deserialize<'de>;
}

impl ResponseExt for Response {
    fn deserialize<T>(&self) -> Result<T>
    where
        T: for<'de> Deserialize<'de>,
    {
        sonic_rs::from_slice(&self.body).map_err(|e| {
            HelixError::DeserializationError(format!("Failed to deserialize response: {}", e))
        })
    }

    fn json(&self) -> Result<sonic_rs::Value> {
        self.deserialize()
    }

    fn get_field<T>(&self, field: &str) -> Result<T>
    where
        T: for<'de> Deserialize<'de>,
    {
        use std::collections::HashMap;

        // Deserialize to HashMap first
        let map: HashMap<String, sonic_rs::Value> = self.deserialize()?;

        // Get field
        let field_value = map
            .get(field)
            .ok_or_else(|| HelixError::MissingField(field.to_string()))?;

        // Deserialize the field value
        sonic_rs::from_value(field_value).map_err(|e| {
            HelixError::DeserializationError(format!(
                "Failed to deserialize field '{}': {}",
                field, e
            ))
        })
    }
}
