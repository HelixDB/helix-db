use crate::AiAction;
use crate::output::{self, Operation};
use crate::project::ProjectContext;
use crate::prompts;
use crate::utils::print_instructions;
use eyre::{Result, eyre};
use std::collections::BTreeSet;
use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};

const GENERATED_MARKER: &str =
    "<!-- Generated by `helix ai setup`. Edit as needed. Re-run with --force to refresh. -->";

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
enum AgentTarget {
    Claude,
    Cursor,
    Copilot,
    Codex,
}

impl AgentTarget {
    fn from_token(token: &str) -> Result<Self> {
        match token {
            "claude" => Ok(Self::Claude),
            "cursor" => Ok(Self::Cursor),
            "copilot" => Ok(Self::Copilot),
            "codex" => Ok(Self::Codex),
            _ => Err(eyre!(
                "Unknown agent target '{}'. Use one of: claude,cursor,copilot,codex,all",
                token
            )),
        }
    }

    fn label(&self) -> &'static str {
        match self {
            Self::Claude => "Claude",
            Self::Cursor => "Cursor",
            Self::Copilot => "Copilot",
            Self::Codex => "Codex",
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum FileWriteStatus {
    Created,
    Updated,
    Unchanged,
    Skipped,
}

impl FileWriteStatus {
    fn as_str(&self) -> &'static str {
        match self {
            FileWriteStatus::Created => "created",
            FileWriteStatus::Updated => "updated",
            FileWriteStatus::Unchanged => "unchanged",
            FileWriteStatus::Skipped => "skipped",
        }
    }
}

struct ManagedFile {
    path: &'static str,
    content: String,
}

#[derive(Default)]
struct GenerationSummary {
    created: usize,
    updated: usize,
    unchanged: usize,
    skipped: usize,
}

impl GenerationSummary {
    fn push(&mut self, status: FileWriteStatus) {
        match status {
            FileWriteStatus::Created => self.created += 1,
            FileWriteStatus::Updated => self.updated += 1,
            FileWriteStatus::Unchanged => self.unchanged += 1,
            FileWriteStatus::Skipped => self.skipped += 1,
        }
    }
}

pub struct SetupOptions {
    pub path: Option<String>,
    pub agents: Option<String>,
    pub yes: bool,
    pub force: bool,
    pub copy_prompt: bool,
}

pub async fn run(action: AiAction) -> Result<()> {
    match action {
        AiAction::Setup {
            path,
            agents,
            yes,
            force,
            copy_prompt,
        } => setup(SetupOptions {
            path,
            agents,
            yes,
            force,
            copy_prompt,
        }),
    }
}

pub fn setup(options: SetupOptions) -> Result<()> {
    let target_root = resolve_target_root(options.path.as_deref())?;
    let targets = parse_targets(options.agents.as_deref())?;
    let files = render_managed_files(&targets);

    let op = Operation::new("Generating", "AI onboarding files");
    let mut summary = GenerationSummary::default();

    for file in files {
        let absolute_path = target_root.join(file.path);
        let status = write_managed_file(
            &absolute_path,
            &file.content,
            options.force,
            options.yes,
            prompts::is_interactive(),
        )?;
        summary.push(status);

        output::info(&format!(
            "{} {}",
            status.as_str().to_uppercase(),
            absolute_path.display()
        ));
    }

    op.success();
    let root_display = target_root.to_string_lossy().to_string();
    let created = summary.created.to_string();
    let updated = summary.updated.to_string();
    let unchanged = summary.unchanged.to_string();
    let skipped = summary.skipped.to_string();
    Operation::print_details(&[
        ("Root", root_display.as_str()),
        ("Created", created.as_str()),
        ("Updated", updated.as_str()),
        ("Unchanged", unchanged.as_str()),
        ("Skipped", skipped.as_str()),
    ]);

    let prompt_path = target_root.join("HELIX_AI_SETUP_PROMPT.md");
    if should_copy_prompt(options.copy_prompt, options.yes)? {
        let prompt_content = fs::read_to_string(&prompt_path)
            .map_err(|e| eyre!("Failed to read prompt at {}: {}", prompt_path.display(), e))?;

        match try_copy_to_clipboard(&prompt_content) {
            Ok(()) => output::success("Copied HELIX_AI_SETUP_PROMPT.md to clipboard"),
            Err(e) => {
                output::warning(&format!(
                    "Could not copy prompt to clipboard ({}). You can copy it manually from {}",
                    e,
                    prompt_path.display()
                ));
            }
        }
    }

    let mut next_steps = vec![
        format!("Review generated files under {}", target_root.display()),
        "Commit the generated AI setup files once reviewed".to_string(),
    ];

    if targets.contains(&AgentTarget::Claude) {
        next_steps.push(
            "In Claude Code, point teammates to .claude/skills for task-specific behavior"
                .to_string(),
        );
    }

    let next_refs: Vec<&str> = next_steps.iter().map(String::as_str).collect();
    print_instructions("Next steps:", &next_refs);

    Ok(())
}

fn resolve_target_root(path: Option<&str>) -> Result<PathBuf> {
    if let Some(path) = path {
        return Ok(PathBuf::from(path));
    }

    if let Ok(project) = ProjectContext::find_and_load(None) {
        return Ok(project.root);
    }

    let cwd = env::current_dir()?;
    output::warning("No helix.toml found. Generating AI files in the current directory.");
    Ok(cwd)
}

fn parse_targets(raw: Option<&str>) -> Result<BTreeSet<AgentTarget>> {
    let mut targets = BTreeSet::new();

    let Some(raw) = raw else {
        targets.insert(AgentTarget::Claude);
        return Ok(targets);
    };

    for token in raw
        .split(',')
        .map(|token| token.trim().to_lowercase())
        .filter(|token| !token.is_empty())
    {
        if token == "all" {
            targets.insert(AgentTarget::Claude);
            targets.insert(AgentTarget::Cursor);
            targets.insert(AgentTarget::Copilot);
            targets.insert(AgentTarget::Codex);
            continue;
        }

        targets.insert(AgentTarget::from_token(&token)?);
    }

    if targets.is_empty() {
        targets.insert(AgentTarget::Claude);
    }

    let selected = targets
        .iter()
        .map(AgentTarget::label)
        .collect::<Vec<_>>()
        .join(", ");
    output::info(&format!("Selected agent targets: {selected}"));

    Ok(targets)
}

fn render_managed_files(targets: &BTreeSet<AgentTarget>) -> Vec<ManagedFile> {
    let mut files = vec![
        ManagedFile {
            path: "HELIX_AI_SETUP_PROMPT.md",
            content: render_setup_prompt(),
        },
        ManagedFile {
            path: "AGENTS.md",
            content: render_agents_md(),
        },
    ];

    if targets.contains(&AgentTarget::Claude) {
        files.push(ManagedFile {
            path: ".claude/skills/helix-author-hql/SKILL.md",
            content: render_skill_author_hql(),
        });
        files.push(ManagedFile {
            path: ".claude/skills/helix-mcp-tools/SKILL.md",
            content: render_skill_mcp_tools(),
        });
        files.push(ManagedFile {
            path: ".claude/skills/helix-cli-workflows/SKILL.md",
            content: render_skill_cli_workflows(),
        });
    }

    if targets.contains(&AgentTarget::Cursor) {
        files.push(ManagedFile {
            path: ".cursor/rules/helix.mdc",
            content: render_cursor_rule(),
        });
    }

    if targets.contains(&AgentTarget::Copilot) {
        files.push(ManagedFile {
            path: ".github/copilot-instructions.md",
            content: render_copilot_instructions(),
        });
    }

    if targets.contains(&AgentTarget::Codex) {
        files.push(ManagedFile {
            path: "CODEX_SETUP.md",
            content: render_codex_setup(),
        });
    }

    files
}

fn write_managed_file(
    path: &Path,
    content: &str,
    force: bool,
    yes: bool,
    interactive: bool,
) -> Result<FileWriteStatus> {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)?;
    }

    if !path.exists() {
        fs::write(path, content)?;
        return Ok(FileWriteStatus::Created);
    }

    let existing = fs::read_to_string(path)?;
    if existing == content {
        return Ok(FileWriteStatus::Unchanged);
    }

    let should_overwrite = if force {
        true
    } else if yes || !interactive {
        false
    } else {
        prompts::confirm_overwrite(path)?
    };

    if should_overwrite {
        fs::write(path, content)?;
        Ok(FileWriteStatus::Updated)
    } else {
        Ok(FileWriteStatus::Skipped)
    }
}

fn should_copy_prompt(copy_prompt: bool, yes: bool) -> Result<bool> {
    if copy_prompt {
        return Ok(true);
    }

    if !prompts::is_interactive() || yes {
        return Ok(false);
    }

    prompts::confirm_copy_ai_prompt()
}

fn try_copy_to_clipboard(text: &str) -> std::result::Result<(), String> {
    #[cfg(target_os = "macos")]
    {
        return copy_with_command("pbcopy", &[], text);
    }

    #[cfg(target_os = "windows")]
    {
        return copy_with_command("clip", &[], text);
    }

    #[cfg(all(not(target_os = "macos"), not(target_os = "windows")))]
    {
        for (cmd, args) in [
            ("wl-copy", vec![]),
            ("xclip", vec!["-selection", "clipboard"]),
            ("xsel", vec!["--clipboard", "--input"]),
        ] {
            if copy_with_command(cmd, &args, text).is_ok() {
                return Ok(());
            }
        }

        Err("no clipboard utility found".to_string())
    }
}

fn copy_with_command(command: &str, args: &[&str], text: &str) -> std::result::Result<(), String> {
    let mut child = Command::new(command)
        .args(args)
        .stdin(Stdio::piped())
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .spawn()
        .map_err(|e| format!("{} not available: {}", command, e))?;

    if let Some(stdin) = child.stdin.as_mut() {
        stdin
            .write_all(text.as_bytes())
            .map_err(|e| format!("failed writing to {} stdin: {}", command, e))?;
    }

    let status = child
        .wait()
        .map_err(|e| format!("failed waiting for {}: {}", command, e))?;

    if status.success() {
        Ok(())
    } else {
        Err(format!("{} exited with non-zero status", command))
    }
}

fn render_setup_prompt() -> String {
    format!(
        r#"{marker}

# Helix AI Setup Prompt

You are helping with a HelixDB project.

## Canonical CLI command map

- Use `helix init` to create a project
- Use `helix add` to add instances
- Use `helix check` to validate config and queries
- Use `helix build <instance>` to build
- Use `helix push <instance>` to deploy or start
- Use `helix sync <instance>` to pull remote cloud source/config
- Use `helix logs <instance>` for logs
- Use `helix dashboard start` for dashboard
- Use `helix auth login` for cloud authentication

## Important command guardrails

- Do not suggest or run deprecated/incorrect commands:
  - `helix deploy`
  - `helix login`
  - `helix pull`
  - `helix install`

## Helix project conventions

- `helix.toml` is the source of truth for project + instances
- Query files live under the configured `project.queries` directory (default `./db/`)
- Keep schema definitions in `schema.hx`
- Keep executable query definitions in `queries.hx`

## Safe editing behavior

- Prefer additive changes over destructive rewrites
- Do not remove existing user queries unless requested
- If generated files already exist, preserve custom edits unless explicitly asked to regenerate
"#,
        marker = GENERATED_MARKER
    )
}

fn render_agents_md() -> String {
    format!(
        r#"{marker}

# AGENTS

This project includes optional AI onboarding files generated by `helix ai setup`.

## Recommended workflow

1. Read `HELIX_AI_SETUP_PROMPT.md` before starting implementation tasks.
2. If using Claude Code, load skills under `.claude/skills/` when relevant.
3. Use `helix check` before `helix push`.
4. Keep `helix.toml` in sync with deployment reality.

## Canonical command reminders

- `helix init`, `helix add`, `helix check`, `helix build`, `helix push`
- `helix auth login`, `helix sync`, `helix logs`, `helix dashboard start`
"#,
        marker = GENERATED_MARKER
    )
}

fn render_skill_author_hql() -> String {
    format!(
        r#"{marker}

# Helix Skill: Author HQL

Use this skill when creating or editing Helix schema and query files.

## Focus

- Author and update `schema.hx` and `queries.hx`
- Keep query signatures clean and typed
- Preserve existing schema names unless migration is requested

## Workflow

1. Read current schema and query files under the configured queries directory.
2. Make minimal, explicit changes.
3. Run `helix check` to validate syntax and semantics.
4. If deployment is requested, use `helix push <instance>`.

## Guardrails

- Do not invent legacy commands like `helix deploy`.
- Do not assume `helix pull` exists.
- Use MCP-related query macros only when requested.
"#,
        marker = GENERATED_MARKER
    )
}

fn render_skill_mcp_tools() -> String {
    format!(
        r#"{marker}

# Helix Skill: MCP Tools

Use this skill when tasks involve Helix MCP endpoints, MCP-enabled queries, or AI traversal tooling.

## Focus

- MCP endpoint semantics (`mcp/init`, `mcp/next`, `mcp/collect`, traversal tools)
- `#[mcp]` query macro usage in HelixQL
- Agent-facing tool design and naming

## Workflow

1. Confirm MCP is enabled in the target instance config (`mcp = true`).
2. Keep MCP query names descriptive and input signatures simple.
3. Prefer explicit connection lifecycle in examples (`init`, then traversal, then `collect`/`reset`).
4. Validate query changes with `helix check`.

## Guardrails

- Prioritize deterministic tool names and stable schemas.
- Avoid broad refactors when only MCP exposure is requested.
"#,
        marker = GENERATED_MARKER
    )
}

fn render_skill_cli_workflows() -> String {
    format!(
        r#"{marker}

# Helix Skill: CLI Workflows

Use this skill when helping users onboard, deploy, debug, or recover Helix CLI projects.

## Canonical commands

- Project setup: `helix init`, `helix add`
- Validation/build/deploy: `helix check`, `helix build`, `helix push`
- Operations: `helix status`, `helix logs`, `helix stop`, `helix restart`, `helix prune`
- Cloud auth and sync: `helix auth login`, `helix sync`

## Workflow

1. Identify instance target from `helix.toml`.
2. Validate with `helix check` before deployment.
3. Use `helix push <instance>` for deploy/start.
4. Use `helix logs <instance>` and `helix status` for diagnosis.

## Guardrails

- Never suggest `helix deploy`, `helix install`, or `helix login`.
- Do not assume cloud auth exists; instruct `helix auth login` when needed.
"#,
        marker = GENERATED_MARKER
    )
}

fn render_cursor_rule() -> String {
    format!(
        r#"{marker}

# Helix CLI + HQL Rules

- Use current Helix CLI commands only: `init`, `add`, `check`, `build`, `push`, `sync`, `logs`, `dashboard`, `auth login`.
- Never suggest deprecated commands (`deploy`, `login`, `pull`, `install`).
- Prefer edits that preserve existing query contracts unless migration is requested.
- Run `helix check` after changing `schema.hx` or `queries.hx`.
"#,
        marker = GENERATED_MARKER
    )
}

fn render_copilot_instructions() -> String {
    format!(
        r#"{marker}

# Copilot Instructions for Helix Projects

- Use `helix.toml` as the source of truth for instance names and query directory.
- After query/schema edits, recommend `helix check`.
- For local deploy/start, recommend `helix push <instance>`.
- For cloud authentication, recommend `helix auth login`.

## Disallowed command suggestions

- `helix deploy`
- `helix login`
- `helix pull`
- `helix install`
"#,
        marker = GENERATED_MARKER
    )
}

fn render_codex_setup() -> String {
    format!(
        r#"{marker}

# Codex Setup for Helix Projects

Use these defaults when working in Helix repositories:

- Read `helix.toml` first to discover instances and query paths.
- Prefer `helix check` before any deployment command.
- Use `helix push <instance>` for local/cloud deployment.
- Use `helix logs <instance>` and `helix status` for diagnostics.

## Avoid stale CLI commands

Do not use:

- `helix deploy`
- `helix login`
- `helix pull`
- `helix install`
"#,
        marker = GENERATED_MARKER
    )
}
